---
layout: post
title: Simmy and Azure App Configuration
comments: true
excerpt: In the latest post, I introduced you Simmy and we saw all the benefits of chaos engineering and how Simmy helps us making chaos in our systems injecting faults, latency or custom behavior in order to make sure that our resilience strategies are correctly implemented and guarantee that our system is able to withstand turbulence conditions in a production environment. Also, I walked you through an example using Simmy in a distributed architecture, where one of the pieces that we had was a chaos settings microservice which took care of to store and get the chaos settings, however we found that that approach has a downside which could be important to consider, it adds extra latency since it has to retrieve the chaos settings from the API in every request. That’s why in this post we’re going to see how using Azure App Configuration we can manage our chaos settings avoiding to inject extra latency or additional overhead to our system.
keywords: "chaos engineering, resilience, resiliency, resiliency testing, fault injection, polly resilience, fault tolerance, fault based testing, fault tolerant, distributed systems, microservices, simmy, polly simmy, monkey, monkeys, chaos, simian army, inject latency, inject behavior, inject result, inject exception, chaos policies, monkey policies, transient-fault-handling, error-handling, transient fault handling, error handling, retry, circuit-breaker, circuit breaker, timeout, bulkhead isolation, fallback, PolicyWrap, netflix, simian, simian army, netflix simian army, .net, .net core, dotnet, dotnet core, azure app configuration, app configuration, azure"
published: false
---

In the [latest post](http://elvanydev.com/chaos-injection-with-simmy/), I introduced you [Simmy](https://github.com/Polly-Contrib/Simmy) and we saw all the benefits of [chaos engineering](http://principlesofchaos.org/) and how Simmy helps us making chaos in our systems injecting [faults](https://github.com/Polly-Contrib/Simmy#Inject-fault), [latency](https://github.com/Polly-Contrib/Simmy#inject-latency) or custom [behavior](https://github.com/Polly-Contrib/Simmy#inject-behavior) in order to make sure that our resilience strategies are correctly implemented and guarantee that our system is able to withstand turbulence conditions in a production environment. Also, I walked you through an [example](http://elvanydev.com/chaos-injection-with-simmy/#hands-on-lab) using Simmy in a distributed architecture, where one of the pieces that we had was a [chaos settings microservice](http://elvanydev.com/chaos-injection-with-simmy/#chaos-settings-microservice) which took care of to store and get the chaos settings, however we found that that approach has a downside which could be important to consider: it adds extra latency since it has to retrieve the chaos settings from the [API](http://elvanydev.com/chaos-injection-with-simmy/#how-does-it-get-the-chaos-settings) in every request. That's why in this post we're going to see how using [Azure App Configuration](https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview) we can manage our chaos settings avoiding to inject extra latency or additional overhead to our system.




